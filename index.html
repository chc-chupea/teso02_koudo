<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>æ‰‹ç›¸ãƒŸãƒ©ã‚¤è¨ºæ–­ - å…¨éƒ¨å…¥ã‚Šãƒ†ãƒ³ãƒ—ãƒ¬</title>
<style>
  body { font-family: "Yu Gothic", sans-serif; background:#fff0f6; color:#5a3e36; text-align:center; margin:0; padding:1rem;}
  #video, #outputCanvas, #edgeCanvas {
    width: 320px; height: 240px; border-radius: 12px; background:#eee; margin:0.5rem auto; display:block;
  }
  #diagnosisResult {
    margin-top:1rem; padding:1rem; background:#ffe6f0; border-radius:1rem; max-width:320px; margin-left:auto; margin-right:auto; text-align:left;
  }
  button {
    padding:0.6rem 1rem; font-size:1rem; border-radius:0.5rem; border:none; background:#f48abf; color:#fff; cursor:pointer;
  }
  button:disabled {
    background:#f9c0d6; cursor:not-allowed;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>

<h1>æ‰‹ç›¸ãƒŸãƒ©ã‚¤è¨ºæ–­ï¼ˆå…¨éƒ¨å…¥ã‚Šãƒ†ãƒ³ãƒ—ãƒ¬ï¼‰</h1>

<video id="video" autoplay playsinline muted></video>
<canvas id="outputCanvas" width="320" height="240"></canvas>
<canvas id="edgeCanvas" width="320" height="240"></canvas>

<button id="startBtn">ã‚«ãƒ¡ãƒ©èµ·å‹•</button>
<button id="captureBtn" disabled>è¨ºæ–­ç”¨ã‚­ãƒ£ãƒ—ãƒãƒ£</button>

<div id="diagnosisResult"></div>

<script>
  let video = document.getElementById("video");
  let outputCanvas = document.getElementById("outputCanvas");
  let edgeCanvas = document.getElementById("edgeCanvas");
  let ctx = outputCanvas.getContext("2d");
  let edgeCtx = edgeCanvas.getContext("2d");

  let stream = null;
  let hands = null;
  let landmarks = null;
  let opencvReady = false;

  const diagnosisResult = document.getElementById("diagnosisResult");
  const startBtn = document.getElementById("startBtn");
  const captureBtn = document.getElementById("captureBtn");

  // è¨ºæ–­ã‚³ãƒ¡ãƒ³ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆã–ã£ãã‚Šä¾‹ï¼‰
  const lineComments = {
    life: ["ç”Ÿå‘½ç·šã¯ã£ãã‚Šé•·ã„ã€‚å¥åº·ã§ã‚¿ãƒ•ã€‚", "ç”Ÿå‘½ç·šã‚„ã‚„çŸ­ã‚ã€‚æ³¨æ„å¿…è¦ã€‚"],
    emotion: ["æ„Ÿæƒ…ç·šã—ã£ã‹ã‚Šã€‚æƒ…ç†±çš„ã€‚", "æ„Ÿæƒ…ç·šè–„ã‚ã€‚å†·é™æ´¾ã‹ã‚‚ã€‚"],
    brain: ["é ­è„³ç·šä¼¸ã³ã¦å¤šæ‰ã€‚", "é ­è„³ç·šçŸ­ã‚ã§é›†ä¸­åŠ›ã‚ã‚Šã€‚"],
    fate: ["é‹å‘½ç·šå¼·ãã¦è»¢æ©Ÿå¤šã„ã€‚", "é‹å‘½ç·šè–„ãå¤‰åŒ–å°‘ãªã‚ã€‚"],
    marriage: ["çµå©šç·š2æœ¬ã§æºã‚Œã‚‹æ™‚æœŸã€‚", "çµå©šç·š1æœ¬ã§å®‰å®šæœŸã€‚"]
  };

  // OpenCV.jsæº–å‚™å¾…ã¡
  function onOpenCvReady() {
    console.log("OpenCV.js is ready");
    opencvReady = true;
    captureBtn.disabled = false;
  }
  // OpenCV.jsãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’ç›£è¦–
  if (typeof cv === "undefined") {
    document.addEventListener('opencvready', onOpenCvReady);
  } else {
    onOpenCvReady();
  }

  // MediaPipe HandsåˆæœŸåŒ–
  function initHands() {
    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    hands.onResults(onHandsResults);
  }

  // ã‚«ãƒ¡ãƒ©èµ·å‹•
  async function startCamera() {
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}, audio:false});
    video.srcObject = stream;
    await video.play();
    captureBtn.disabled = false;
  }

  // MediaPipeã§æ‰‹æ¤œå‡º
  async function detectHands() {
    if (!hands) initHands();
    await hands.send({image: video});
  }

  // æ‰‹æ¤œå‡ºçµæœã§æç”»ã¨ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ä¿å­˜
  function onHandsResults(results) {
    ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    ctx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      landmarks = results.multiHandLandmarks[0];
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color:"#00FF00", lineWidth:3});
      drawLandmarks(ctx, landmarks, {color:"#FF0000", lineWidth:2});
    } else {
      landmarks = null;
    }
  }

  // ç·šã®ä½ç½®åˆ¤å®šï¼ˆè¶…ã–ã£ãã‚Šåº§æ¨™ä¾‹ï¼‰ã§æ“¬ä¼¼åˆ†é¡
  function classifyLines(edgeMat) {
    // ä»®ï¼šæ‰‹ã®é ˜åŸŸä¸­å¤®ã‹ã‚‰ä¸‹ã‚ãŸã‚Šã§é•·ã‚ã®æ›²ç·šæ¤œå‡ºâ†’ç”Ÿå‘½ç·šãªã©åˆ¤å®š
    // ã“ã“ã¯è¦èª¿æ•´ã€‚ä»Šã¯ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿”ã™å½¢ã«
    let result = {
      life: lineComments.life[Math.floor(Math.random()*lineComments.life.length)],
      emotion: lineComments.emotion[Math.floor(Math.random()*lineComments.emotion.length)],
      brain: lineComments.brain[Math.floor(Math.random()*lineComments.brain.length)],
      fate: lineComments.fate[Math.floor(Math.random()*lineComments.fate.length)],
      marriage: lineComments.marriage[Math.floor(Math.random()*lineComments.marriage.length)]
    };
    return result;
  }

  // ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼†ã‚¨ãƒƒã‚¸æŠ½å‡ºï¼†åˆ¤å®š
  function captureAndAnalyze() {
    if (!opencvReady) {
      alert("OpenCV.jsã®èª­ã¿è¾¼ã¿ãŒã¾ã å®Œäº†ã—ã¦ã„ã¾ã›ã‚“ã€‚");
      return;
    }
    if (!landmarks) {
      alert("æ‰‹ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚");
      return;
    }
    // outputCanvasã®ç”»åƒã‚’OpenCVã«èª­ã¿è¾¼ã¿
    let src = cv.imread(outputCanvas);
    let gray = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
    cv.Canny(gray, edges, 50, 150);

    cv.imshow(edgeCanvas, edges);

    // ç·šåˆ†é¡ï¼ˆæ“¬ä¼¼ï¼‰
    let classification = classifyLines(edges);

    // è¨ºæ–­çµæœè¡¨ç¤º
    diagnosisResult.innerHTML = `
      <h3>ğŸ– ã‚ãªãŸã®æ‰‹ç›¸çµæœ</h3>
      <ul>
        <li>ãƒ»ç”Ÿå‘½ç·šï¼š${classification.life}</li>
        <li>ãƒ»æ„Ÿæƒ…ç·šï¼š${classification.emotion}</li>
        <li>ãƒ»é ­è„³ç·šï¼š${classification.brain}</li>
        <li>ãƒ»é‹å‘½ç·šï¼š${classification.fate}</li>
        <li>ãƒ»çµå©šç·šï¼š${classification.marriage}</li>
      </ul>
    `;

    // å¾Œç‰‡ä»˜ã‘
    src.delete(); gray.delete(); edges.delete();
  }

  startBtn.addEventListener("click", async () => {
    startBtn.disabled = true;
    await startCamera();
    // é€£ç¶šæ¤œå‡º
    const detectLoop = async () => {
      await detectHands();
      requestAnimationFrame(detectLoop);
    };
    detectLoop();
  });

  captureBtn.addEventListener("click", captureAndAnalyze);
</script>

</body>
</html>